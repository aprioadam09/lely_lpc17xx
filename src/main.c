#include <cmsis.h>

#include <lely/co/nmt.h>
#include <lely/co/sdev.h>
#include <lely/co/sdo.h>
#include <lely/co/rpdo.h>
#include <lely/co/tpdo.h>
#include <lely/co/time.h>

#include <assert.h>
#include <stdlib.h>
#include <time.h>

#include <can.h>
#include "chip.h"

extern void __librt_init(void);
extern void __librt_fini(void);

extern void __libnosys_init(void);
extern void __libnosys_fini(void);

#ifndef CAN_BITRATE
#define CAN_BITRATE 125000
#endif

static int on_can_send(const struct can_msg *msg, void *data);
static void on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data);
static void on_time(co_time_t *time, const struct timespec *tp, void *data);
static co_unsigned32_t on_dn_2000_00(co_sub_t *sub, struct co_sdo_req *req,
		void *data);
static co_unsigned32_t on_up_2001_00(const co_sub_t *sub,
		struct co_sdo_req *req, void *data);
static co_unsigned32_t on_dn_led_control(co_sub_t *sub, struct co_sdo_req *req,
		void *data);
static bool last_button_state = true;

// Generated by `dcf2c --no-strings lpc17xx.dcf lpc17xx_sdev -o src/sdev.c`
extern const struct co_sdev lpc17xx_sdev;

// Tambahkan fungsi ini untuk memberikan delay singkat
void simple_delay(volatile uint32_t count) {
    while (count--) {
        __NOP(); // No operation, hanya membuang waktu
    }
}

int
main(void)
{
	__librt_init();
	//__libnosys_init();

	can_init(CAN_BITRATE);

	// ---- Inisialisasi Hardware LED ----
	Chip_GPIO_SetPinDIROutput(LPC_GPIO, 3, 25);
	Chip_GPIO_SetPinDIROutput(LPC_GPIO, 3, 26);

	Chip_GPIO_SetPinState(LPC_GPIO, 3, 25, true); // true = HIGH = LED Mati
	Chip_GPIO_SetPinState(LPC_GPIO, 3, 26, true);
	// ------------------------------------

	// ---- Inisialisasi Hardware Tombol ----
	// Set pin P2.10 (Tombol SW2) sebagai input
	Chip_GPIO_SetPinDIRInput(LPC_GPIO, 2, 10);
	// ------------------------------------

	// Initialize the CAN network interface.
	can_net_t *net = can_net_create();
	assert(net);
	can_net_set_send_func(net, &on_can_send, NULL);

	// Initialize the CAN network clock. We use the monotonic clock, since
	// its reference will not be changed by clock_settime().
	struct timespec now = { 0, 0 };
	clock_gettime(CLOCK_MONOTONIC, &now);
	can_net_set_time(net, &now);

	// Create a dynamic object dictionary from the static object dictionary.
	co_dev_t *dev = co_dev_create_from_sdev(&lpc17xx_sdev);
	assert(dev);

	// Create the CANopen NMT service.
	co_nmt_t *nmt = co_nmt_create(net, dev);
	assert(nmt);

	// Create and start the RPDO service to listen for LED commands
	co_rpdo_t *rpdo1 = co_rpdo_create(net, dev, 1);
	assert(rpdo1);
	co_rpdo_start(rpdo1);

	// Start the NMT service by resetting the node.
	co_nmt_cs_ind(nmt, CO_NMT_CS_RESET_NODE);

	// Set the NMT indication function _after_ the initial reset; otherwise
	// we create a reset loop.
	co_nmt_set_cs_ind(nmt, &on_nmt_cs, NULL);

	// Set the TIME indication function. This can only be done when the TIME
	// service is active.
	co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);

	// Set the download (SDO write) indication function for sub-object
	// 2000:01.
	co_sub_set_dn_ind(co_dev_find_sub(dev, 0x2000, 0x00), &on_dn_2000_00,
			NULL);

	// Set the upload (SDO read) indication function for sub-object 2001:01.
	co_sub_set_up_ind(co_dev_find_sub(dev, 0x2001, 0x00), &on_up_2001_00,
			NULL);

	co_sub_set_dn_ind(co_dev_find_sub(dev, 0x2100, 0x00), &on_dn_led_control,
			NULL);

	for (;;) {
		// Update the CAN network clock.
		clock_gettime(CLOCK_MONOTONIC, &now);
		can_net_set_time(net, &now);

		// Process any received CAN frames.
		struct can_msg msg;
		while (can_recv(&msg, 1))
			can_net_recv(net, &msg);

		// TODO: Update object dictionary.

		// ---- Logika Baca Tombol dengan Debouncing ----
		bool current_button_state = Chip_GPIO_GetPinState(LPC_GPIO, 2, 10);

		// Cek apakah ada perubahan dari state stabil terakhir
		if (current_button_state != last_button_state) {
		    // Perubahan terdeteksi, tunggu sebentar untuk debouncing
		    simple_delay(500000); // Sesuaikan nilai ini jika perlu

		    // Baca lagi status tombol setelah delay
		    current_button_state = Chip_GPIO_GetPinState(LPC_GPIO, 2, 10);

		    // Jika setelah delay statusnya masih sama dengan perubahan awal,
		    // maka ini adalah perubahan yang valid
		    if (current_button_state != last_button_state) {
		        last_button_state = current_button_state;

		        uint8_t od_value = current_button_state ? 0 : 1; // 0 = dilepas, 1 = ditekan

		        co_sub_t *sub = co_dev_find_sub(dev, 0x2110, 0x00);
		        if (sub) {
		            co_sub_set_val_u8(sub, od_value);
		            co_dev_tpdo_event(dev, 0x2110, 0x00);
		        }
		    }
		}
		// Wait for an interrupt to occur.
		__WFI();
	}

	co_rpdo_destroy(rpdo1);
	co_nmt_destroy(nmt);
	co_dev_destroy(dev);
	can_net_destroy(net);

	can_fini();

	//__libnosys_fini();
	__librt_fini();

	return 0;
}

static int
on_can_send(const struct can_msg *msg, void *data)
{
	(void)data;

	return can_send(msg, 1) == 1 ? 0 : -1;
}

static void
on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data)
{
	(void)data;

	switch (cs) {
	case CO_NMT_CS_START:
		// Reset the TIME indication function, since the service may
		// have been restarted.
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_STOP:
		break;
	case CO_NMT_CS_ENTER_PREOP:
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_RESET_NODE:
		// Initiate a system reset.
		exit(0);
		break;
	case CO_NMT_CS_RESET_COMM:
		break;
	}
}

static void
on_time(co_time_t *time, const struct timespec *tp, void *data)
{
	(void)time;
	(void)data;

	// Update the wall clock, _not_ the monotonic clock used by the CAN
	// network.
	clock_settime(CLOCK_REALTIME, tp);
}

static co_unsigned32_t
on_dn_2000_00(co_sub_t *sub, struct co_sdo_req *req, void *data)
{
	assert(sub);
	assert(co_obj_get_idx(co_sub_get_obj(sub)) == 0x2000);
	assert(co_sub_get_subidx(sub) == 0x00);
	assert(req);
	// The data pointer can be used to pass user-specified data to the
	// callback function. It is the last argument passed to
	// co_sub_set_dn_ind().
	(void)data;

	co_unsigned32_t ac = 0;

	co_unsigned16_t type = co_sub_get_type(sub);
	assert(type == CO_DEFTYPE_UNSIGNED32);

	// This callback is invoked for every SDO CAN frame. Unless the value is
	// too large to be held in memory (for example, during a firmware
	// update), it is more convenient to wait until the entire value is
	// received. This is what the following call is designed to do. It
	// returns -1 with ac == 0 if more CAN frames are pending.
	union co_val val;
	if (co_sdo_req_dn_val(req, type, &val, &ac) == -1)
		return ac;

	// Check if the value is valid.
	if (val.u32 != 42) {
		ac = CO_SDO_AC_PARAM;
		goto error;
	}

	// TODO: Do something with val.u32.

	// Write the temporary value to the local object dictionary.
	co_sub_dn(sub, &val);
error:
	// Finalize the temporary value. This is only necessary to cleanup array
	// values, but it is a good practice to always include it.
	co_val_fini(type, &val);
	return ac;
}

static co_unsigned32_t
on_up_2001_00(const co_sub_t *sub, struct co_sdo_req *req, void *data)
{
	assert(co_obj_get_idx(co_sub_get_obj(sub)) == 0x2001);
	assert(co_sub_get_subidx(sub) == 0x00);
	assert(req);
	(void)data;

	co_unsigned16_t type = co_sub_get_type(sub);
	assert(type == CO_DEFTYPE_UNSIGNED32);

	// TODO: Obtain value from somewhere.
	co_unsigned32_t val = 42;

	// Store the value in the send buffer.
	co_unsigned32_t ac = 0;
	co_sdo_req_up_val(req, type, &val, &ac);
	return ac;
}

static co_unsigned32_t
on_dn_led_control(co_sub_t *sub, struct co_sdo_req *req, void *data)
{
	assert(sub);
	assert(co_obj_get_idx(co_sub_get_obj(sub)) == 0x2100);
	assert(co_sub_get_subidx(sub) == 0x00);
	assert(req);
	(void)data;

	co_unsigned32_t ac = 0;
	co_unsigned16_t type = co_sub_get_type(sub);
	assert(type == CO_DEFTYPE_UNSIGNED8);

	union co_val val;
	if (co_sdo_req_dn_val(req, type, &val, &ac) == -1)
		return ac;

	// On the LPCXpresso board, the LED is on when the pin is LOW.
	Chip_GPIO_SetPinState(LPC_GPIO, 3, 25, !(val.u8 & 0x01));
	Chip_GPIO_SetPinState(LPC_GPIO, 3, 26, !(val.u8 & 0x02));
	// -------------------------------

	// Write the temporary value to the local object dictionary.
	co_sub_dn(sub, &val);
	// Finalize the temporary value.
	co_val_fini(type, &val);
	return ac;
}
