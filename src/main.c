#include <cmsis.h>

#include <lely/co/nmt.h>
#include <lely/co/sdev.h>
#include <lely/co/time.h>

#include <assert.h>
#include <stdlib.h>
#include <time.h>

#include <can.h>

extern void __librt_init(void);
extern void __librt_fini(void);

extern void __libnosys_init(void);
extern void __libnosys_fini(void);

#ifndef CAN_BITRATE
#define CAN_BITRATE 125000
#endif

static int on_can_send(const struct can_msg *msg, void *data);
static void on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data);
static void on_time(co_time_t *time, const struct timespec *tp, void *data);

// Generated by `dcf2c --no-strings lpc17xx.dcf lpc17xx_sdev -o src/sdev.c`
extern const struct co_sdev lpc17xx_sdev;

int
main(void)
{
	__librt_init();
	__libnosys_init();

	can_init(CAN_BITRATE);

	// Initialize the CAN network interface.
	can_net_t *net = can_net_create();
	assert(net);
	can_net_set_send_func(net, &on_can_send, NULL);

	// Initialize the CAN network clock. We use the monotonic clock, since
	// its reference will not be changed by clock_settime().
	struct timespec now = { 0, 0 };
	clock_gettime(CLOCK_MONOTONIC, &now);
	can_net_set_time(net, &now);

	// Create a dynamic object dictionary from the static object dictionary.
	co_dev_t *dev = co_dev_create_from_sdev(&lpc17xx_sdev);
	assert(dev);

	// Create the CANopen NMT service.
	co_nmt_t *nmt = co_nmt_create(net, dev);
	assert(nmt);

	// Start the NMT service by resetting the node.
	co_nmt_cs_ind(nmt, CO_NMT_CS_RESET_NODE);

	// Set the NMT indication function _after_ the initial reset; otherwise
	// we create a reset loop.
	co_nmt_set_cs_ind(nmt, &on_nmt_cs, NULL);

	// Set the TIME indication function. This can only be done when the TIME
	// service is active.
	co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);

	for (;;) {
		// Update the CAN network clock.
		clock_gettime(CLOCK_MONOTONIC, &now);
		can_net_set_time(net, &now);

		// Process any received CAN frames.
		struct can_msg msg;
		while (can_recv(&msg, 1))
			can_net_recv(net, &msg);

		// Wait for an interrupt to occur.
		__WFI();
	}

	co_nmt_destroy(nmt);
	co_dev_destroy(dev);
	can_net_destroy(net);

	can_fini();

	__libnosys_fini();
	__librt_fini();

	return 0;
}

static int
on_can_send(const struct can_msg *msg, void *data)
{
	(void)data;

	return can_send(msg, 1) == 1 ? 0 : -1;
}

static void
on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data)
{
	(void)data;

	switch (cs) {
	case CO_NMT_CS_START:
		// Reset the TIME indication function, since the service may
		// have been restarted.
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_STOP:
		break;
	case CO_NMT_CS_ENTER_PREOP:
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_RESET_NODE:
		// Initiate a system reset.
		exit(0);
		break;
	case CO_NMT_CS_RESET_COMM:
		break;
	}
}

static void
on_time(co_time_t *time, const struct timespec *tp, void *data)
{
	(void)time;
	(void)data;

	// Update the wall clock, _not_ the monotonic clock used by the CAN
	// network.
	clock_settime(CLOCK_REALTIME, tp);
}
