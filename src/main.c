#include <cmsis.h>

#include <lely/co/nmt.h>
#include <lely/co/sdev.h>
#include <lely/co/sdo.h>
#include <lely/co/time.h>

#include <assert.h>
#include <stdlib.h>
#include <time.h>

#include <can.h>

extern void __librt_init(void);
extern void __librt_fini(void);

extern void __libnosys_init(void);
extern void __libnosys_fini(void);

#ifndef CAN_BITRATE
#define CAN_BITRATE 125000
#endif

static int on_can_send(const struct can_msg *msg, void *data);
static void on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data);
static void on_time(co_time_t *time, const struct timespec *tp, void *data);
static co_unsigned32_t on_dn_2000_00(co_sub_t *sub, struct co_sdo_req *req,
		void *data);
static co_unsigned32_t on_up_2001_00(const co_sub_t *sub,
		struct co_sdo_req *req, void *data);

// Generated by `dcf2c --no-strings lpc17xx.dcf lpc17xx_sdev -o src/sdev.c`
extern const struct co_sdev lpc17xx_sdev;

int
main(void)
{
	__librt_init();
	//__libnosys_init();

	can_init(CAN_BITRATE);

	// Initialize the CAN network interface.
	can_net_t *net = can_net_create();
	assert(net);
	can_net_set_send_func(net, &on_can_send, NULL);

	// Initialize the CAN network clock. We use the monotonic clock, since
	// its reference will not be changed by clock_settime().
	struct timespec now = { 0, 0 };
	clock_gettime(CLOCK_MONOTONIC, &now);
	can_net_set_time(net, &now);

	// Create a dynamic object dictionary from the static object dictionary.
	co_dev_t *dev = co_dev_create_from_sdev(&lpc17xx_sdev);
	assert(dev);

	// Create the CANopen NMT service.
	co_nmt_t *nmt = co_nmt_create(net, dev);
	assert(nmt);

	// Start the NMT service by resetting the node.
	co_nmt_cs_ind(nmt, CO_NMT_CS_RESET_NODE);

	// Set the NMT indication function _after_ the initial reset; otherwise
	// we create a reset loop.
	co_nmt_set_cs_ind(nmt, &on_nmt_cs, NULL);

	// Set the TIME indication function. This can only be done when the TIME
	// service is active.
	co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);

	// Set the download (SDO write) indication function for sub-object
	// 2000:01.
	co_sub_set_dn_ind(co_dev_find_sub(dev, 0x2000, 0x00), &on_dn_2000_00,
			NULL);

	// Set the upload (SDO read) indication function for sub-object 2001:01.
	co_sub_set_up_ind(co_dev_find_sub(dev, 0x2001, 0x00), &on_up_2001_00,
			NULL);

	for (;;) {
		// Update the CAN network clock.
		clock_gettime(CLOCK_MONOTONIC, &now);
		can_net_set_time(net, &now);

		// Process any received CAN frames.
		struct can_msg msg;
		while (can_recv(&msg, 1))
			can_net_recv(net, &msg);

		// TODO: Update object dictionary.

		// Wait for an interrupt to occur.
		__WFI();
	}

	co_nmt_destroy(nmt);
	co_dev_destroy(dev);
	can_net_destroy(net);

	can_fini();

	//__libnosys_fini();
	__librt_fini();

	return 0;
}

static int
on_can_send(const struct can_msg *msg, void *data)
{
	(void)data;

	return can_send(msg, 1) == 1 ? 0 : -1;
}

static void
on_nmt_cs(co_nmt_t *nmt, co_unsigned8_t cs, void *data)
{
	(void)data;

	switch (cs) {
	case CO_NMT_CS_START:
		// Reset the TIME indication function, since the service may
		// have been restarted.
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_STOP:
		break;
	case CO_NMT_CS_ENTER_PREOP:
		co_time_set_ind(co_nmt_get_time(nmt), &on_time, NULL);
		break;
	case CO_NMT_CS_RESET_NODE:
		// Initiate a system reset.
		exit(0);
		break;
	case CO_NMT_CS_RESET_COMM:
		break;
	}
}

static void
on_time(co_time_t *time, const struct timespec *tp, void *data)
{
	(void)time;
	(void)data;

	// Update the wall clock, _not_ the monotonic clock used by the CAN
	// network.
	clock_settime(CLOCK_REALTIME, tp);
}

static co_unsigned32_t
on_dn_2000_00(co_sub_t *sub, struct co_sdo_req *req, void *data)
{
	assert(sub);
	assert(co_obj_get_idx(co_sub_get_obj(sub)) == 0x2000);
	assert(co_sub_get_subidx(sub) == 0x00);
	assert(req);
	// The data pointer can be used to pass user-specified data to the
	// callback function. It is the last argument passed to
	// co_sub_set_dn_ind().
	(void)data;

	co_unsigned32_t ac = 0;

	co_unsigned16_t type = co_sub_get_type(sub);
	assert(type == CO_DEFTYPE_UNSIGNED32);

	// This callback is invoked for every SDO CAN frame. Unless the value is
	// too large to be held in memory (for example, during a firmware
	// update), it is more convenient to wait until the entire value is
	// received. This is what the following call is designed to do. It
	// returns -1 with ac == 0 if more CAN frames are pending.
	union co_val val;
	if (co_sdo_req_dn_val(req, type, &val, &ac) == -1)
		return ac;

	// Check if the value is valid.
	if (val.u32 != 42) {
		ac = CO_SDO_AC_PARAM;
		goto error;
	}

	// TODO: Do something with val.u32.

	// Write the temporary value to the local object dictionary.
	co_sub_dn(sub, &val);
error:
	// Finalize the temporary value. This is only necessary to cleanup array
	// values, but it is a good practice to always include it.
	co_val_fini(type, &val);
	return ac;
}

static co_unsigned32_t
on_up_2001_00(const co_sub_t *sub, struct co_sdo_req *req, void *data)
{
	assert(co_obj_get_idx(co_sub_get_obj(sub)) == 0x2001);
	assert(co_sub_get_subidx(sub) == 0x00);
	assert(req);
	(void)data;

	co_unsigned16_t type = co_sub_get_type(sub);
	assert(type == CO_DEFTYPE_UNSIGNED32);

	// TODO: Obtain value from somewhere.
	co_unsigned32_t val = 42;

	// Store the value in the send buffer.
	co_unsigned32_t ac = 0;
	co_sdo_req_up_val(req, type, &val, &ac);
	return ac;
}
